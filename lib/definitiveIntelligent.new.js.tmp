/**
 * DEFINITIVE INTELLIGENT SYSTEM
 * Generates DAT-compatible city pairs with freight intelligence
 */
import { adminSupabase } from '../utils/supabaseClient.js';
import { findDatCompatibleCities } from './datCityFinder.js';
import { smartVerifyCity } from './datVerificationLearner.js';
import { calculateDistance } from './distanceCalculator.js';
import { validateCityCoordinates } from './cityValidator.js';

/**
 * Calculate freight intelligence score for a city pair
 */
function calculateFreightScore(pickup, delivery, baseOrigin, baseDest) {
  let score = 1.0;

  // Distance efficiency (closer is better within limits)
  const pickupDistance = calculateDistance(
    Number(baseOrigin.latitude), Number(baseOrigin.longitude),
    Number(pickup.latitude), Number(pickup.longitude)
  );
  const deliveryDistance = calculateDistance(
    Number(baseDest.latitude), Number(baseDest.longitude),
    Number(delivery.latitude), Number(delivery.longitude)
  );

  // Penalize distances over 75 miles
  if (pickupDistance > 75) score *= 0.9;
  if (deliveryDistance > 75) score *= 0.9;

  // Bonus for different KMAs (geographical diversity)
  if (pickup.kma_code !== baseOrigin.kma_code) score *= 1.2;
  if (delivery.kma_code !== baseDest.kma_code) score *= 1.2;

  // Bonus for verified cities
  if (pickup.dat_verified) score *= 1.3;
  if (delivery.dat_verified) score *= 1.3;

  // Population bonuses (larger cities = better infrastructure)
  if (pickup.population > 50000) score *= 1.1;
  if (delivery.population > 50000) score *= 1.1;

  return score;
}

/**
 * Generates optimized DAT-compatible city pairs
 */
export default async function generateDefinitiveIntelligentPairs(origin, destination) {
  try {
    console.log('ðŸ“ TEST CASE: Major Market Test');
    console.log(`Base Route: ${origin.city}, ${origin.state} -> ${destination.city}, ${destination.state}`);

    // Get full city data from database
    const { data: cityData, error: cityError } = await adminSupabase
      .from('cities')
      .select('*')
      .or(`city.ilike.${origin.city},city.ilike.${destination.city}`)
      .or(`state_or_province.ilike.${origin.state},state_or_province.ilike.${destination.state}`);

    if (cityError) {
      console.error('Error fetching city data:', cityError);
      return { pairs: [], baseOrigin: origin, baseDest: destination };
    }

    // Find matching cities
    const baseOrigin = cityData.find(c => 
      c.city.toLowerCase() === origin.city.toLowerCase() &&
      c.state_or_province.toLowerCase() === origin.state.toLowerCase()
    );
    const baseDest = cityData.find(c => 
      c.city.toLowerCase() === destination.city.toLowerCase() &&
      c.state_or_province.toLowerCase() === destination.state.toLowerCase()
    );

    if (!baseOrigin || !baseDest) {
      console.error('Base cities not found:', { origin, destination });
      return { pairs: [], baseOrigin: origin, baseDest: destination };
    }

    // Validate coordinates
    if (!validateCityCoordinates(baseOrigin) || !validateCityCoordinates(baseDest)) {
      console.error('Invalid coordinates for base cities');
      return { pairs: [], baseOrigin: origin, baseDest: destination };
    }

    // Verify cities with HERE.com
    console.log(`ðŸ” Verifying cities via HERE.com...`);
    await Promise.all([
      smartVerifyCity(baseOrigin),
      smartVerifyCity(baseDest)
    ]);

    // Get DAT-compatible cities within range
    console.log('ðŸ” Finding DAT-compatible cities...');
    const pickupCities = await findDatCompatibleCities(baseOrigin, 75, 10);
    const deliveryCities = await findDatCompatibleCities(baseDest, 75, 10);

    // Generate all possible pairs
    const pairs = [];
    const usedCities = new Set();

    for (const pickup of pickupCities) {
      for (const delivery of deliveryCities) {
        const pairKey = `${pickup.city},${pickup.state_or_province}->${delivery.city},${delivery.state_or_province}`;
        if (usedCities.has(pairKey)) continue;

        const score = calculateFreightScore(pickup, delivery, baseOrigin, baseDest);
        
        pairs.push({
          pickup: {
            city: pickup.city,
            state: pickup.state_or_province,
            zip: pickup.zip
          },
          delivery: {
            city: delivery.city,
            state: delivery.state_or_province,
            zip: delivery.zip
          },
          geographic: {
            pickup_kma: pickup.kma_code,
            delivery_kma: delivery.kma_code,
            pickup_distance: calculateDistance(
              Number(baseOrigin.latitude), Number(baseOrigin.longitude),
              Number(pickup.latitude), Number(pickup.longitude)
            ),
            delivery_distance: calculateDistance(
              Number(baseDest.latitude), Number(baseDest.longitude),
              Number(delivery.latitude), Number(delivery.longitude)
            )
          },
          score,
          intelligence: 'freight_optimized'
        });

        usedCities.add(pairKey);
      }
    }

    // Sort by score and pick the best 5 pairs
    const selectedPairs = pairs
      .sort((a, b) => b.score - a.score)
      .slice(0, 5);

    console.log(`âœ… Generated ${selectedPairs.length} DAT-compatible pairs`);
    selectedPairs.forEach((pair, i) => {
      console.log(`  ${i + 1}. ${pair.pickup.city}, ${pair.pickup.state} -> ${pair.delivery.city}, ${pair.delivery.state} (Score: ${pair.score.toFixed(2)})`);
    });

    return {
      pairs: selectedPairs,
      baseOrigin: {
        city: baseOrigin.city,
        state: baseOrigin.state_or_province,
        zip: baseOrigin.zip
      },
      baseDest: {
        city: baseDest.city,
        state: baseDest.state_or_province,
        zip: baseDest.zip
      }
    };

  } catch (error) {
    console.error('Error generating intelligent pairs:', error);
    return { pairs: [], baseOrigin: origin, baseDest: destination };
  }
}
