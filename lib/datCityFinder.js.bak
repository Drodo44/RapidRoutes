// lib/datCityFinder.js
// Intelligent DAT-compatible city finder with KMA awareness

import { adminSupabase as supabase } from '../utils/supabaseClient.js';
import { calculateDistance } from './distanceCalculator.js';
    cities = cities
      .filter(city => city.latitude && city.longitude) // Filter out cities without coordinates
      .map(city => ({
        ...city,
        distance: calculateDistance(
          Number(cityData.latitude),
          Number(cityData.longitude),
          Number(city.latitude),
          Number(city.longitude)
        )
      }))
      .filter(city => city.distance <= maxDistance)
      .sort((a, b) => a.distance - b.distance);abase as supabase } from '../utils/supabaseClient.js';
import { calculateDistance } from './distanceCalculator.js';

/**
 * Find DAT-verified cities within a KMA and its adjacent KMAs
 */
export async function findDatVerifiedCitiesInKma(kmaCode, excludedCities = new Set(), limit = 10) {
  try {
    // First try cities in the same KMA
    const { data: sameMka } = await supabase
      .from('cities')
      .select('*')
      .eq('kma_code', kmaCode)
      .order('created_at', { ascending: false })
      .limit(limit);

    if (sameMka?.length >= limit) {
      return sameMka.filter(city => !excludedCities.has(`${city.city},${city.state_or_province}`));
    }

    // If we need more, look in adjacent KMAs
    const { data: kmaData } = await supabase
      .from('kma_adjacency')
      .select('adjacent_kma')
      .eq('kma_code', kmaCode)
      .limit(5);

    if (!kmaData?.length) return sameMka || [];

    const adjacentKmas = kmaData.map(k => k.adjacent_kma);
    
    const { data: adjacentCities } = await supabase
      .from('cities')
      .select('*')
      .in('kma_code', adjacentKmas)
      .order('created_at', { ascending: false })
      .limit(limit - (sameMka?.length || 0));

    const allCities = [...(sameMka || []), ...(adjacentCities || [])];
    return allCities.filter(city => !excludedCities.has(`${city.city},${city.state_or_province}`));
  } catch (error) {
    console.error('Error finding DAT cities:', error);
    return [];
  }
}

/**
 * Find DAT-compatible cities within distance limits, preferring same or adjacent KMAs
 */
export async function findDatCompatibleCities(baseCity, maxDistance = 75, minCities = 5) {
  try {
    // Log the city we're looking for
    console.log(`🔍 Finding compatible cities for: ${baseCity.city}, ${baseCity.state_or_province}`);

    // Get base city KMA with proper case-insensitive search
    const { data: baseCityData, error: kmaError } = await supabase
      .from('cities')
      .select('id, city, state_or_province, kma_code, latitude, longitude')
      .ilike('city', baseCity.city)
      .ilike('state_or_province', baseCity.state_or_province);

    if (kmaError) {
      console.error('Error finding city KMA:', kmaError);
      return [];
    }

    if (!baseCityData?.length) {
      console.warn(`⚠️ City not found in database: ${baseCity.city}, ${baseCity.state_or_province}`);
      return [];
    }

    // Find best matching city
    const cityData = baseCityData.find(c => 
      c.city.toLowerCase() === baseCity.city.toLowerCase() &&
      c.state_or_province.toLowerCase() === baseCity.state_or_province.toLowerCase()
    ) || baseCityData[0];

    if (!cityData.kma_code) {
      console.warn(`⚠️ No KMA code for ${cityData.city}, ${cityData.state_or_province}`);
      return [];
    }

    console.log(`✓ Found KMA: ${cityData.kma_code} for ${cityData.city}, ${cityData.state_or_province}`);

    // Find cities in same KMA first
    let cities = await findDatVerifiedCitiesInKma(cityData.kma_code);
    
    // Filter by distance and sort by freight score
    cities = cities
      .map(city => ({
        ...city,
        distance: calculateDistance(
          cityData.latitude,
          cityData.longitude,
          city.latitude,
          city.longitude
        )
      }))
      .filter(city => city.distance <= maxDistance)
      .sort((a, b) => a.freight_score - b.freight_score);

    // If we don't have enough cities, try expanding the search
    if (cities.length < minCities && maxDistance < 100) {
      const expandedCities = await findDatCompatibleCities(baseCity, 100, minCities);
      cities = [...cities, ...expandedCities]
        .filter((city, index, self) => 
          index === self.findIndex(c => c.city === city.city && c.state_or_province === city.state_or_province)
        )
        .slice(0, minCities);
    }

    return cities;
  } catch (error) {
    console.error('Error in findDatCompatibleCities:', error);
    return [];
  }
}
